package models.bench

import java.util.concurrent.atomic.AtomicInteger

import scala.concurrent.duration.{ Duration, DurationInt, FiniteDuration }

import org.joda.time.{ DateTime, Interval }

import BenchmarkRequester.{ BenchmarkRequesterConfig, RequesterStats, StatsTick }
import akka.actor.{ ActorRef, Props }
import models.ResponseEnvelope
import models.akka.{ CommProxy, DSLinkMode, IntCounter }
import models.rpc._

/**
 * Simulates a Requester that subscribes to a responder's node updates and then repeatedly
 * calls the action that causes that node to be updated
 */
class BenchmarkRequester(linkName: String, proxy: CommProxy, config: BenchmarkRequesterConfig)
  extends AbstractEndpointActor(linkName, DSLinkMode.Requester, proxy) {

  import context.dispatcher

  private val ridGen = new IntCounter(1)

  private var lastReported: RequesterStats = _
  private val invokesSent = new AtomicInteger(0)
  private val updatesReceived = new AtomicInteger(0)

  override def preStart() = {
    super.preStart

    lastReported = RequesterStats(linkName, new Interval(DateTime.now, DateTime.now), 0, 0)

    // subscribe to path events
    val subReq = SubscribeRequest(ridGen.inc, SubscriptionPath(config.path, 101))
    proxy ! RequestMessage(localMsgId.inc, None, List(subReq))
    log.info("[{}] subscribed to [{}]", linkName, config.path)

    // schedule action invocation
    val invPath = config.path + "/incCounter"
    context.system.scheduler.schedule(config.timeout, config.timeout) {
      val requests = (1 to config.batchSize) map (_ => InvokeRequest(ridGen.inc, invPath))
      proxy ! RequestMessage(localMsgId.inc, None, requests.toList)
      invokesSent.addAndGet(config.batchSize)
      log.debug("[{}]: sent a batch of {} InvokeRequests to {}", linkName, config.batchSize, config.path)
    }

    if (config.statsInterval > Duration.Zero)
      context.system.scheduler.schedule(config.statsInterval, config.statsInterval, self, StatsTick)
  }

  override def postStop() = {
    // unsubscribe from path
    val unsReq = UnsubscribeRequest(ridGen.inc, List(101))
    proxy ! RequestMessage(localMsgId.inc, None, List(unsReq))
    log.info("Requester[{}] unsubscribed from [{}]", linkName, config.path)

    super.postStop
  }

  def receive = {
    case env @ ResponseEnvelope(responses) =>
      log.debug("[{}]: received {}", linkName, env)
      val updateCount = responses.map(_.updates.getOrElse(Nil).size).sum
      updatesReceived.addAndGet(updateCount)

    case StatsTick => reportStats

    case msg       => log.warning("[{}]: received unknown message - {}", msg)
  }

  private def reportStats() = {
    val interval = new Interval(lastReported.interval.getEnd, DateTime.now)
    val stats = RequesterStats(linkName, interval, invokesSent.get - lastReported.invokesSent,
      updatesReceived.get - lastReported.updatesReceived)
    log.info("[{}]: collected {}", linkName, stats)
    config.statsCollector foreach (_ ! stats)
    lastReported = stats
  }
}

/**
 * Factory for [[BenchmarkRequester]] instances.
 */
object BenchmarkRequester {
  /**
   * BenchmarkRequester configuration.
   */
  case class BenchmarkRequesterConfig(path: String, batchSize: Int, timeout: FiniteDuration,
                                      statsInterval:  FiniteDuration   = 5 seconds,
                                      statsCollector: Option[ActorRef] = None)

  /**
   * Creates a new [[BenchmarkRequester]] props instance.
   */
  def props(linkName: String, proxy: CommProxy, config: BenchmarkRequesterConfig) =
    Props(new BenchmarkRequester(linkName, proxy, config))

  /**
   * Sent by scheduler to initiate stats reporting.
   */
  case object StatsTick

  /**
   * Stats generated by the requester, sent to the stats collector.
   */
  case class RequesterStats(id: String, interval: Interval, invokesSent: Int, updatesReceived: Int)
}