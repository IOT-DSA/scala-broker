package models.bench

import scala.concurrent.duration.{DurationInt, FiniteDuration}
import org.joda.time.{DateTime, Interval}
import BenchmarkRequester.{BenchmarkRequesterConfig, ReqStatsSample}
import akka.actor.{ActorRef, Cancellable, Props}
import akka.routing.Routee
import models.{ResponseEnvelope, ResponseEnvelopeFormat}
import models.akka.{DSLinkMode, IntCounter, RichRoutee}
import models.metrics.Meter
import models.rpc._

/**
 * Simulates a Requester that subscribes to a responder's node updates and then repeatedly
 * calls the action that causes that node to be updated
 */
class BenchmarkRequester(linkName: String, routee: Routee, config: BenchmarkRequesterConfig)
  extends AbstractEndpointActor(linkName, DSLinkMode.Requester, routee, config)
  with Meter {

  import BenchmarkRequester._

  import context.dispatcher

  private val ridGen = new IntCounter(1)
  private var invokeJob: Cancellable = null

  private var lastReportedAt: DateTime = _
  private var invokesSent: Int = 0
  private var updatesRcvd: Int = 0

  private val linkAddress = "localhost"

  private val invPath = config.path + "/incCounter"

  /**
   * Optionally subscribes to the node's updates and schedules a regular job for pushing request batches.
   */
  override def preStart() = {
    super.preStart

    lastReportedAt = DateTime.now

    // subscribe to path events
    if (config.subscribe) {
      val subReq = SubscribeRequest(ridGen.inc, SubscriptionPath(config.path, 101))
      sendToProxy(RequestMessage(localMsgId.inc, None, List(subReq)))
      log.info("[{}] subscribed to [{}]", linkName, config.path)
    }

    // schedule action invocation
    invokeJob = context.system.scheduler.schedule(config.timeout, config.timeout, self, SendBatch)
  }

  /**
   * Unsubscribes from the responder's updates.
   */
  override def postStop() = {
    invokeJob.cancel

    // unsubscribe from path
    if (config.subscribe) {
      val unsReq = UnsubscribeRequest(ridGen.inc, List(101))
      sendToProxy(RequestMessage(localMsgId.inc, None, List(unsReq)))
      log.info("Requester[{}] unsubscribed from [{}]", linkName, config.path)
    }

    super.postStop
  }

  /**
   * Event loop.
   */
  override def receive = super.receive orElse {
    case env: ResponseEnvelope =>
      val responses = viaJson(env).responses
      log.debug("[{}]: received {}", linkName, env)
      val updateCount = responses.map { rsp =>
        math.max(rsp.updates.getOrElse(Nil).size, 1)
      }.sum
      updatesRcvd += updateCount

      meterTagsNTimes(tagsWithPrefix("requester.benchmark.in.responses")(s"address.$linkAddress"))(responses.size)
      meterTagsNTimes(tagsWithPrefix("requester.benchmark.in.responses.updates")(s"address.$linkAddress"))(updateCount)
    case SendBatch =>
      val requests = ridGen.inc(config.batchSize) map (idx => InvokeRequest(idx, invPath))
      sendToProxy(RequestMessage(localMsgId.inc, None, requests.toList))
      invokesSent += config.batchSize
      log.debug("[{}]: sent a batch of {} InvokeRequests to {}", linkName, config.batchSize, config.path)

    case msg => log.warning("[{}]: received unknown message - {}", msg)
  }

  /**
   * Sends the statistics to the aggregator.
   */
  protected def reportStats() = {
    val now = DateTime.now
    val interval = new Interval(lastReportedAt, now)
    val stats = ReqStatsSample(linkName, interval, invokesSent, updatesRcvd)
    log.debug("[{}]: collected {}", linkName, stats)
    config.statsCollector foreach (_ ! stats)
    invokesSent = 0
    updatesRcvd = 0
    lastReportedAt = now
  }

  /**
   * Sends request message to the DSLink actor.
   */
  protected def sendToProxy(msg: RequestMessage) = {
    val message = viaJson[RequestMessage, DSAMessage](msg)
    routee ! message

    meterTags(tagsWithPrefix("requester.benchmark.out.requests")(s"address.$linkAddress"))
  }
}

/**
 * Factory for [[BenchmarkRequester]] instances.
 */
object BenchmarkRequester {
  import AbstractEndpointActor._

  /**
   * Message sent by the scheduler to trigger a batch sending.
   */
  case object SendBatch

  /**
   * BenchmarkRequester configuration.
   */
  case class BenchmarkRequesterConfig(subscribe:      Boolean,
                                      path:           String,
                                      batchSize:      Int,
                                      timeout:        FiniteDuration,
                                      parseJson:      Boolean,
                                      statsInterval:  FiniteDuration   = 5 seconds,
                                      statsCollector: Option[ActorRef] = None) extends EndpointConfig

  /**
   * Creates a new [[BenchmarkRequester]] props instance.
   */
  def props(linkName: String, routee: Routee, config: BenchmarkRequesterConfig) =
    Props(new BenchmarkRequester(linkName, routee, config))

  /**
   * Stats generated by the requester, sent to the stats collector.
   */
  case class ReqStatsSample(id: String, interval: Interval, invokesSent: Int, updatesRcvd: Int)
    extends ReqStatsBehavior { val duration = interval.toDuration }
}